<!DOCTYPE html>
<meta charset="utf-8">

<style>

.parentToMetric:hover {
  text-decoration: underline;
  cursor: pointer;
}

</style>

<body>
<script src="d3.v3.min.js"></script>
<script src="queue.v1.min.js"></script>

<script src='https://api.tiles.mapbox.com/mapbox.js/v2.2.1/mapbox.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/v2.2.1/mapbox.css' rel='stylesheet' />

<div id="container" style="font-family: Helvetica, Arial, sans-serif; position: absolute; bottom: 0%; top: 0; left: 0; right: 50%; background: #fff;">
  <div style="position: absolute; left: 2em;">
    <h3 style="font-size: 1em; margin-top: 1em">Index for Risk Management 2015 Scores</h3>
    <h1 style="font-size: 3.2em; margin-top: 0;"></h1>
  </div>
  <div style="position: absolute; left: 30%; right: 30%; top: 46%; bottom: 49%; text-align: center;">
    <p id="thisMetricParentParentParent" class="parentToMetric" style="font-size: 0.6em; color: #d7d7d8;"></p>
    <p id="thisMetricParentParent" class="parentToMetric" style="font-size: 0.75em; color: #9f9fa3;"></p>
    <p id="thisMetricParent" class="parentToMetric" style="font-size: 0.9em; color: #6d6e70;"></p>
    <p id="thisMetric" style="font-size: 1.3em; color: #000; padding-top: 0;"></p>
  </div>
</div>
<div id="map" style="position: absolute; bottom: 0%; top: 0%; left: 50%; right: 0%; background: #fff;"></div>

<!-- Array with hierarchy of fields -->
<script src="field-hierarchy.js"></script>

<!-- Load countries geojson object -->
<script src="countries.js"></script>

<script>

// Hard code staring points
var selectedMetric = "INFORM RISK";
var selectedCountry = "Somalia";

// Returns index of an attribute with a certain value within an array
var findIndex = function(array, attr, value) {
    for(var i = 0; i < array.length; i++) {
        if(array[i][attr] === value) {
            return i;
        }
    }
}

var selectedMetricIndex = findIndex(fieldHierarchy, "field", selectedMetric);

// Visual variables
var width = document.getElementById("container").clientWidth * 2,
    height = document.getElementById("container").clientHeight * 0.9,
    tau = 2 * Math.PI,
    inner = width / 8,
    outer = width / 5,
    colors = ["#FFEFF4","#F7BBBF", "#ed1b2e"],
    oppositeColors = ["#eee", "#fff", "#fff"];

var color = d3.scale.linear()
		.domain([0, 2.5, 6.5])
		.range([colors[0], colors[1], colors[2]])
		.interpolate(d3.interpolateLab);

var oppositeColor = d3.scale.linear()
		.domain([0.1, 6, 10])
		.range([oppositeColors[0], oppositeColors[1], oppositeColors[2]])
		.interpolate(d3.interpolateLab);

// Empty arrays
var visibleFields = [];
var visibleArcs = [];
var backgroundArcs = [];
var textArcs = [];

// Create the SVG container, and apply a transform such that the origin is the center of the canvas
var svg = d3.select("#container").append("svg")
    .attr("width", width / 2)
    .attr("height", height *1.1)
  .append("g")
    .attr("transform", "translate(" + width / 4 + "," + height / 1.5 + ")");

// Create and svg grouping to hold our visualization arcs
var backgroundArcGroup = svg.append("g");
var arcGroup = svg.append("g");
var textArcGroup = svg.append("g");

// Add all fields that should be currently represented with arcs to the visibleFields array
var populateVisibleFields = function() {
  visibleFields = fieldHierarchy[selectedMetricIndex].subset;
}
populateVisibleFields();

// A function that, given a metric name, returns the parent metric
var parentMetric = function(metric) {
  for (var i = 0; i < fieldHierarchy.length; i++) {
    for (var j = 0; j < fieldHierarchy[i].subset.length; j++) {
      if (fieldHierarchy[i].subset[j] === metric) {
        return fieldHierarchy[i].field;
      }
    }
  }
}

// Load data
queue()
    .defer(d3.csv, "natural-disaster-risk.csv")
    .await(ready);

// READY
function ready(error, risk) {
  if (error) throw error;

  /////////
  // MAP //
  /////////

  // Add map
  L.mapbox.accessToken = 'pk.eyJ1IjoiYWFyb25kZW5uaXMiLCJhIjoiem5LLURoYyJ9.T3tswGTI5ve8_wE-a02cMw';
  var map = L.mapbox.map('map', 'mapbox.high-contrast',
                          { zoomControl: false,
                            tileLayer: {
                                continuousWorld: false,
                                noWrap: true
                            },
                            maxZoom: 6
                          }).fitBounds([[12.02464,51.13387],[-1.68325,40.98105]]);

  var choroplethLayer = L.geoJson().addTo(map);

  function onEachFeature(feature, layer) {
        layer.on({
            //mouseover: highlightFeature,
            //mouseout: resetHighlight,
            click: clickedFeature
        });
  }

  var clickedLayer = undefined;

  // Zooming map to country
  function clickedFeature(e) {

    selectCountry(risk[findIndex(risk, "ISO3", e.target.feature.properties.ISO3)]["COUNTRY"]);
    map.fitBounds(e.target.getBounds());

    colorMap();

  }

/*
  function highlightFeature(e) {

    var layer = e.target;

    layer.setStyle({
        weight: 4,
        color: '#666',
        dashArray: '',
    });

    if (!L.Browser.ie && !L.Browser.opera) {
        layer.bringToFront();
    }
  } //*/

  function resetHighlight(e) {
    var layer = e.target;

    layer.setStyle({
        weight: 0,
        color: '#666',
        dashArray: '',
    });

  }

  // Color the map based on metric
  function colorMap() {

    map.removeLayer(choroplethLayer);

    choroplethLayer = L.geoJson(countriesData,  {
        style: getStyle,
        onEachFeature: onEachFeature
    }).addTo(map);

  }

  // function that styles layer
  function getStyle(feature) {
      return {
          weight: getWeight(feature),
          color: "#666",
          fillOpacity: 0.7,
          fillColor: getColor(feature)
      };
  }

  function getWeight(feature) {
    if (feature.properties.ISO3 === getISO3(selectedCountry)) {
      console.log("the feature being drawn matches " + getISO3(selectedCountry));
      return 6;
    } else {
      return 0;
    }
  }

  function getColor(feature) {
    var iso3Value = (feature.properties.ISO3);
    var theValue = getValue(iso3Value);
    if (theValue) {
      return color(theValue);
    } else {
      return "#aaa";
    }
  }

  // grap value of the selected metric given country code
  function getValue(key) {
    if (findIndex(risk, "ISO3", key)) {
      return parseFloat(risk[findIndex(risk, "ISO3", key)][selectedMetric]); }
    else {
      return undefined;
    }
  }




  // Respond to a country selection
  var selectCountry = function(countryName) {

    selectedCountry = countryName;
    selectedCountryIndex = findIndex(risk, "COUNTRY", selectedCountry);

    // Response functions
    displayArcs();
    displayCountryText();
    displayMetricText();

  }
  selectCountry("Somalia");

  // Respond to a metric selection
  var selectMetric = function(metricName) {

    selectedMetric = metricName;
    selectedMetricIndex = findIndex(fieldHierarchy, "field", selectedMetric);

    // Response functions
    colorMap();
    displayArcs();
    displayMetricText();

  }
  selectMetric("INFORM RISK");

  // Displaying arcs
  function displayArcs() {

    populateVisibleFields();

    backgroundArcGroup.selectAll("path").remove();
    arcGroup.selectAll("path").remove();
    textArcGroup.selectAll("path").remove();
    textArcGroup.selectAll("textPath").remove();
    textArcGroup.selectAll("text").remove();

    generateArcs();

  }

  // Populate country text fields
  function displayCountryText() {

    var countryNameText = d3.select("h1")
    countryNameText.text(selectedCountry);

  }

  // Populate metric text fields
  function displayMetricText() {

      selectedMetricValue = risk[selectedCountryIndex][selectedMetric] === "null" ? "no estimation" : risk[selectedCountryIndex][selectedMetric];

      d3.select("#thisMetric").text(
        selectedMetric.toUpperCase() + ": "
      ).append("span").style("font-weight", "bold").text(selectedMetricValue);

      if (parentMetric(selectedMetric)) {
        d3.select("#thisMetricParent").text(
          parentMetric(selectedMetric).toUpperCase() + ": "
        ).append("span").style("font-weight", "bold").text(risk[selectedCountryIndex][parentMetric(selectedMetric)]);

        d3.select("#thisMetricParent").on("click", function() {

          selectedMetric = parentMetric(selectedMetric);
          selectMetric(selectedMetric);
        });
      } else {
        d3.select("#thisMetricParent").text("");
      }

      if (parentMetric(parentMetric(selectedMetric))) {
        d3.select("#thisMetricParentParent").text(
          parentMetric(parentMetric(selectedMetric)).toUpperCase() + ": "
        ).append("span").style("font-weight", "bold").text(risk[selectedCountryIndex][parentMetric(parentMetric(selectedMetric))])

        d3.select("#thisMetricParentParent").on("click", function() {

          selectedMetric = parentMetric(parentMetric(selectedMetric));
          selectMetric(selectedMetric);

        });
      } else {
        d3.select("#thisMetricParentParent").text("");
      }

      if (parentMetric(parentMetric(parentMetric(selectedMetric)))) {
        d3.select("#thisMetricParentParentParent").text(
          parentMetric(parentMetric(parentMetric(selectedMetric))).toUpperCase() + ": "
        ).append("span").style("font-weight", "bold").text(risk[selectedCountryIndex][parentMetric(parentMetric(selectedMetric))]);

        d3.select("#thisMetricParentParentParent").on("click", function() {

          selectedMetric = parentMetric(parentMetric(parentMetric(selectedMetric)));
          selectMetric(selectedMetric);

        });
      } else {
        d3.select("#thisMetricParentParentParent").text("");
      }

  }


  //////////////////////
  // Helper functions //
  //////////////////////

  function getISO3(nameOfCountry) {
    if (findIndex(risk, "COUNTRY", nameOfCountry)) {
      return risk[findIndex(risk, "COUNTRY", nameOfCountry)]["ISO3"]; }
    else {
      return undefined;
    }
  }

  // Creates an svg arc that can be added to the svg container
  function svgArc(inner, outer, start, end) {
    return d3.svg.arc().innerRadius(inner).outerRadius(outer).startAngle(start + tau / 2).endAngle(end + tau / 2);
  }

  // Fill visibleArcs array with new arcs based on visibleFields array and selectedCountryIndex
  function generateArcs() {

    visibleArcs = [];
    backgroundArcs = [];
    textArcs = [];

    var arcWidth = (outer - inner) / visibleFields.length;

    for (var i = 0; i < visibleFields.length; i++) {

      // Gray background arcs
      var newBackgroundArc = svgArc(inner + 3 + (i * arcWidth),
                                    inner - 3 + (i + 1) * arcWidth,
                                    0.002 * tau,
                                    tau);

      backgroundArcs.push(newBackgroundArc);

      backgroundArcGroup.append("path")
          .style("fill", "#9f9fa3")
          .attr("d", backgroundArcs[i])
          .attr("id", visibleFields[i] + " arc")
          .style("pointer-events", "pointer")
          .on("mouseover", function(d) {
              d3.select(this).style("stroke", "yellow");
            })
          .on("mouseout", function(d) {
              d3.select(this).style("stroke", "#fff");
            })
          .on("click", function(d) {
              var id = this.getAttribute('id');
              selectMetric(id.substring(0, id.length - 4))
            });

      // Visible red arcs
      var theValue = parseFloat(risk[selectedCountryIndex][visibleFields[i]]);

      var newArc = svgArc(inner + 1 + (i * arcWidth),
                          inner - 1 + (i + 1) * arcWidth,
                          0.002 * tau,
                          (theValue / 10) * tau)

      visibleArcs.push(newArc);

      arcGroup.append("path")
          .style("fill", color(theValue))
          .style("cursor", "pointer")
          .attr("class", "arc")
          .attr("d", visibleArcs[i])
          .attr("id", visibleFields[i] + " arc")
          .on("mouseover", function(d) {
              d3.select(this)
                .style("fill", color(theValue * 0.8))
                .style("stroke", "yellow")
                .style("stroke-width", 3)
                .style("stroke-opacity", 0.3);
            })
          .on("mouseout", function(d) {
              d3.select(this).style("fill", color(theValue)).style("stroke", "none");
            })
          .on("click", function(d) {
              var id = this.getAttribute('id');
              selectMetric(id.substring(0, id.length - 4))
            });

      // Arc text labels
      newTextArc = svgArc(inner + (i * arcWidth) + Math.sqrt(arcWidth) * 0.85,
                          inner + Math.sqrt(arcWidth) * 1.5,
                          0.25 * tau,
                          0.75 * tau);

      textArcs.push(newTextArc);

      textArcGroup.append("path")
          .style("opacity", 0)
          .style("pointer-events", "none")
          .attr("d", textArcs[i])
          .attr("id", visibleFields[i] + " text arc");

      textArcGroup
        .append("text")
          .style("font-size", Math.sqrt(arcWidth) * 3)
          .style("fill", oppositeColor(theValue))
          .style("font-family", "Helvetica, Arial, sans-serif")
          .style("pointer-events", "none")
          .attr("id", visibleFields[i] + " text arc")
        .append("textPath")
          .attr("xlink:href","#" + visibleFields[i] + " text arc")
          .style("pointer-events", "pointer")
          .style("text-anchor", "middle")
          .attr("startOffset", "26%")
          .text(visibleFields[i].toUpperCase() + ": " + theValue);

    }
  }

}


</script>
